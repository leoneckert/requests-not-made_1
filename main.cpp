//
//  main.cpp
//  requests_not_made
//
//  Created by Leon Eckert on 06/03/2016.
//  Copyright Â© 2016 Leon Eckert. All rights reserved.
//


#include <iostream>
#include <tins/tins.h>
#include <vector>
#include <string>
#include <sstream>
#include <map>



using namespace Tins;
using namespace std; 

map<string, vector<string>> activeDevices; // Map1
void printActiveDevices(){
    for (auto& y : activeDevices){
        cout << "KEY: " << y.first << endl;
        int c = 0;
        for (auto& x : activeDevices[y.first]){
            cout << "\telem in array[" << c << "]: " << x << endl;
            c++;
        }
    }
}

map<string, map<string, int>> hostsSubHosts; // Map2
void printHostMap(){
    for (auto& y : hostsSubHosts){
        cout << "Main Host: " << y.first << endl;
        for (auto& x : hostsSubHosts[y.first]){
            cout << "\tSubHost :" << x.first << " times called: " << hostsSubHosts[y.first][x.first] << endl;
        }
    }
}



long currentTime(){
    time_t  timev;
    return time(&timev);
}

void updateActiveDevices(const long& activeDuration){
    vector<string> devicesToKill;
    for (auto& y : activeDevices){
        long lastAction = std::stol(activeDevices[y.first][2]);
        if (currentTime() - lastAction >= activeDuration) {
            devicesToKill.push_back(y.first);
        }
    }
    for (auto& x : devicesToKill){
          activeDevices.erase (x);
    }
}

string turnHostIntoShortFrom(const string& _hostname){
    string hostname = _hostname;
    string shortHost = hostname;
    int lengthOrigName = (int) hostname.length();
    int dotCount = 0;
    int cutSpot1;
    int cutSpot2;
    for(int i = 0; i < lengthOrigName; i++){
        string currentLetter = hostname.substr(lengthOrigName - i - 1, 1);
        if (currentLetter ==  "."){
            
            dotCount = dotCount + 1;
            if (dotCount == 1) {
                cutSpot2 = lengthOrigName - i - 1;
                shortHost = shortHost.substr(0, cutSpot2);
            }
            if (dotCount == 2) {
                cutSpot1 = lengthOrigName - i;
                shortHost = shortHost.substr(cutSpot1);
                break;
            }
        }
    }
    return shortHost;
}

//recipe for part2:

//Map1: {MAC: [host, shortHost, timestamp]} << active devices
//Map2: {Host: {subHost: times, subHost: times}

////go through Map1 and delete all keys the timestamp of which is longer than _ seconds ago. [DONE]

////check if MAC address is currently active [DONE]
////if no:                  (this means, the Host was actually requested by the client)
////////add the MACadd, the Host, Host-core (e.g. "nytimes") and timestamp to a map {MAC: [host, shortHost, timestamp]} [DONE]
////////check if Host already has an entry in Map2 [DONE]
////////if yes:
////////////do nothing          (subsequent subHosts will be added) [DONE]
////////if no:
////////////add the Host as a Key to Map2 with and empty dictionairy as its value [DONE]
////if yes:
////////update the timestamp for the MAC key in Map1 [DONE]             !! somewhere we also need to check if its from the same shorthost
////////check if subHost is already in MAP2 of the Host key
////////if yes:
////////////increase the time value of the dictionairy of Host in Map 2
////////if no:
////////////add the subHost as a key (with times value 1) to the dictionairy that is the value of the Host key in Map 2

void processLine(const vector<string>& vectorToPrint, const vector<string>& requestedHeaders){
//this function is desinged to process a input vector of the pattern: host, get, src, dst, timestamp
    if (vectorToPrint.size() == requestedHeaders.size() + 3) {
        string MAC = vectorToPrint[2];
        string host = vectorToPrint[0].substr(6);
        string shortHost = turnHostIntoShortFrom(host);
        host = shortHost;
        string timestamp = vectorToPrint[4];
        
        if (activeDevices.find(MAC) == activeDevices.end()) {
            // not found:
            vector<string> temp;
            temp.push_back(host);
            temp.push_back(shortHost);
            temp.push_back(timestamp);
            activeDevices[MAC] = temp;
            
            if (hostsSubHosts.find(host) == hostsSubHosts.end()) {
                // not found:
                map<string, int> emptymap;
                hostsSubHosts[host] = emptymap;
            } else {
                // found:
                //do nothing
            }
            
        } else {
            // found:
            activeDevices[MAC][2] = timestamp;
            string activeHost = activeDevices[MAC][0];
            if (hostsSubHosts[activeHost].find(host) == hostsSubHosts[activeHost].end()) {
                // not found:
                hostsSubHosts[activeHost][host] = 1;
            } else {
                // found:
                hostsSubHosts[activeHost][host] += 1;
            }
            
        }
        
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////[  GET HEADER FUNCTIONS  ]///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////[ Get Timestamp ]/////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
long get_timestamp(Packet pkt){
    long timestamp = pkt.timestamp().seconds();
    return timestamp;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////////[ Get Src ]///////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
string get_src_from_pdu(const PDU &pdu){
    const Dot11Data &dot11Data = pdu.rfind_pdu<Dot11Data>();
    string src = dot11Data.src_addr().to_string();
    
    return src;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////////[ Get Dst ]///////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
string get_dst_from_pdu(const PDU &pdu){
    const Dot11Data &dot11Data = pdu.rfind_pdu<Dot11Data>();
    string dst = dot11Data.dst_addr().to_string();
    
    return dst;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////[ Get Header ]//////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
string get_header_from_raw(string header, const RawPDU& rawpdu){
    
    string payL = "";
    string content = "";
    const RawPDU::payload_type& payload = rawpdu.payload();
    for (const auto& bit : payload) {
        payL += (char) bit;
    }
    
    int pos_header = (int) payL.find(header);
    
    if(pos_header != -1){
        content = payL.substr(pos_header);
        int endHeader = (int) content.find("\n");
        content = content.substr(0, endHeader - 1);
    }
    
    return content;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////[ Get Raw Pdu ]/////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
const RawPDU& get_raw_pdu(const PDU &pdu){
    const RawPDU &raw = pdu.rfind_pdu<RawPDU>();
    return raw;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
///////////[ Check if Data11 PDU ]//////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
bool hasData11packet(const PDU& pdu){
    try {
        //probably a more elegant solution
        const Dot11Data &dot11Data = pdu.rfind_pdu<Dot11Data>();
        return true;
    }catch (...) {return false;}
}
////////////////////////////////////////////////
////////////////////////////////////////////////
//////[ Get Requested Headers from pkt ]////////
////////////////////////////////////////////////
////////////////////////////////////////////////
vector<string> get_headers_from_pkts(vector<string> requestedHeaders, const Packet& pkt){
    vector<string> output;
    // here is where we do stuff with packets:
    const PDU& pdu = *pkt.pdu();
    
    // check if we find a dot11data packet:
    if (hasData11packet(pdu)) {
        
        // if yes, get the rawPDU and do something with it
        try{
            const RawPDU& raw = get_raw_pdu(pdu);
            
            try{
                
                vector<string> requestedHeadersReturn;
                for(auto h : requestedHeaders){
                    requestedHeadersReturn.push_back(get_header_from_raw(h, raw));
                }
                
                for(auto s : requestedHeadersReturn){
                    // 3 here is quite arbitrary
                    if (s.length() > 3) {
                        output.push_back(s);
                    }
                }
                string src = get_src_from_pdu(pdu);
                string dst = get_dst_from_pdu(pdu);
                string ts;
                stringstream strstream;
                strstream << get_timestamp(pkt);
                strstream >> ts;

                
                output.push_back(src);
                output.push_back(dst);
                output.push_back(ts);
                
            }catch(...){}
            
        }catch(...){}
    }
    return output;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
///////////[ Print out the Output ]/////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
void printOutputVector(const vector<string>& vectorToPrint, const vector<string>& requestedHeaders){
    if (vectorToPrint.size() == requestedHeaders.size() + 3) {
        bool first = true;
        
        for (string s : vectorToPrint){
            if (!first) {
                cout << " , ";
            }
            first = false;
            cout << s;
        }
        cout << endl;
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void startSniffing(std::string _interface, bool monitorMode){
    
    // configure the sniffer:
    std::string interface = _interface;
    SnifferConfiguration config;
    config.set_promisc_mode(true);
    config.set_rfmon(monitorMode);
    Sniffer sniffer(interface, config);
    
    // now sniff:
    try {
        
        while(Packet pkt = sniffer.next_packet()) {
            
            vector<string> headersWanted = {"Host: ","GET"};
            vector<string> headerVector = get_headers_from_pkts(headersWanted, pkt);
            //update Map1, take our old elemenets
            //process vector
            updateActiveDevices(2);
            processLine(headerVector, headersWanted);
//            printActiveDevices();
//            printOutputVector(headerVector, headersWanted);
            printHostMap();
            
        }
    }catch(...){}
    
}

int main(){
    startSniffing("en0", true);
}